#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Sep 28 09:35:26 2017

@author: martin
"""
from collections import Counter
import pandas as pd

class Sequence(object):
    
    def __init__(self, name='', description='', sequence=''):
        self.name = name
        self.description = description
        self.sequence = sequence
        
# Input parser (pir)
"""
Assume our input data looks like the following:
    
SEQUENCES MUST BE OF EQUAL LENGTH

>P1;CRAB_ANAPL
ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN).
  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR 
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH 
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ 
  SDVPERSIPI TREEKPAIAG AQRKK*

>P1;CRAB_BOVIN
ALPHA CRYSTALLIN C CHAIN (ALPHA(C)-CRYSTALLIN).
  MDIAIHHPWI RRPFFPFHSP SRLFDQFFGE HLLESDLFPA STSLSPFYLR 
  PPSFLRAPSW IDTGLSEMRL EKDRFSVNLD VKHFSPEELK VKVLGDVIEV 
  HGKHEERQDE HGFISREFHR KYRIPADVDP LAITSSLSSD GVLTVNGPRK 
  QASGPERTIP ITREEKPAVT AAPKK*
...

"""

def parser(file_name, file_type):
    #accession_number = ''
    accession_id = 0
    tmp_seq = ''
    
    with open(file_name) as data:
        for i, line in enumerate(data):
            line = line.strip().replace(' ', '')
     
            if(line.startswith('>')):
                accession_id = i
                seq = Sequence(name=line)
                
            elif(i == (accession_id + 1)):
                seq.description = line
              
            else:
                tmp_seq += line # Combine fragmented sequences
                if('*' in line): # until *
                    tmp_seq = tmp_seq.replace('*', '')
                    seq.sequence = tmp_seq
                    tmp_seq = '' # Reset sequence var
                    
                    seq_objects.append(seq)

# --------------------------------------------------------------
                    

seq_objects = []

#parser('test.pir', '.pir')
parser('nad3.pir', '.pir')

seq_matrix = [seq_objects[n].sequence for n in range( len(seq_objects) )]

k = [[f for f in s] for s in seq_matrix]


####################################
############ DEFINITIONS ###########
####################################

nr_seqs = len(seq_objects)

# IS  - 50% of nr of sequences + 1
_is = int((nr_seqs * 0.5) + 1)
# FS  - 85% of nr of sequences
_fs = int((nr_seqs * 0.85))
_cp = 8
_bl1 = 15
_bl2 = 10

# Example:
# Nr seqs:  17
# IS:       9.5
# FS:       14.45


####################################


conservation_level = ['n', 'c', 'h']
nc = [0] * nr_seqs # The number of consecutive 'nonconserved' for a residue in the last row

temp = []

new_df = pd.DataFrame()

def classifier(item, freq):
    if(freq < _is or item == '-'):
        return conservation_level[0]
    
    elif((freq > _is) and (freq < _fs)):
        return conservation_level[1]
    
    elif(freq > _fs):
        return conservation_level[2]

def deep_thought(index, row):
    global nc

    for i, item in enumerate(row):
        freq = row.value_counts()[item] # Calculate frequency
        freq = (freq / len(row)) * 100  # Calculate frequency percentage
        
        cons = classifier(item, freq)   # Determine level of conservation
        #print(item, freq, cons)
        
        if(cons == 'n'):                # If current residue is nonconserved
            nc[i] += 1        # Increment counter for that position
        else:
            nc[i] = 0
        

    if(all(v <= _cp for v in nc)):
        temp.append(row.tolist())

#    if(any(v > _cp for v in nc)): # If ANY position has 9 nonconserved residues
#        nc = [0] * nr_seqs        # reset counter   


# Untransposed dataframe
data_frame = pd.DataFrame(k)
# Transposed dataframe
df = data_frame.T #.transpose()

# Lookup dataframe, used to store information about each df entry
# in dictionaries
df_rows = df.shape[0]
df_cols = df.shape[1]


for index,row in df.iterrows():
    (deep_thought(index, row))

print(len(temp))
new_df.append(temp)
        
        
        
        
        
        
        
        
        
        
        
        

